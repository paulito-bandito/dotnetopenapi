/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.1.0 (NJsonSchema v10.1.21.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

namespace com.walterp.todo {

export abstract class ControllerBase implements IControllerBase {
    httpContext?: HttpContext | undefined;
    request?: HttpRequest | undefined;
    response?: HttpResponse | undefined;
    routeData?: RouteData | undefined;
    modelState?: ModelStateDictionary | undefined;
    controllerContext?: ControllerContext | undefined;
    metadataProvider?: IModelMetadataProvider | undefined;
    modelBinderFactory?: IModelBinderFactory | undefined;
    url?: IUrlHelper | undefined;
    objectValidator?: IObjectModelValidator | undefined;
    problemDetailsFactory?: ProblemDetailsFactory | undefined;
    user?: ClaimsPrincipal | undefined;

    constructor(data?: IControllerBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpContext = _data["HttpContext"] ? HttpContext.fromJS(_data["HttpContext"]) : <any>undefined;
            this.request = _data["Request"] ? HttpRequest.fromJS(_data["Request"]) : <any>undefined;
            this.response = _data["Response"] ? HttpResponse.fromJS(_data["Response"]) : <any>undefined;
            this.routeData = _data["RouteData"] ? RouteData.fromJS(_data["RouteData"]) : <any>undefined;
            this.modelState = _data["ModelState"] ? ModelStateDictionary.fromJS(_data["ModelState"]) : <any>undefined;
            this.controllerContext = _data["ControllerContext"] ? ControllerContext.fromJS(_data["ControllerContext"]) : <any>undefined;
            this.metadataProvider = _data["MetadataProvider"] ? IModelMetadataProvider.fromJS(_data["MetadataProvider"]) : <any>undefined;
            this.modelBinderFactory = _data["ModelBinderFactory"] ? IModelBinderFactory.fromJS(_data["ModelBinderFactory"]) : <any>undefined;
            this.url = _data["Url"] ? IUrlHelper.fromJS(_data["Url"]) : <any>undefined;
            this.objectValidator = _data["ObjectValidator"] ? IObjectModelValidator.fromJS(_data["ObjectValidator"]) : <any>undefined;
            this.problemDetailsFactory = _data["ProblemDetailsFactory"] ? ProblemDetailsFactory.fromJS(_data["ProblemDetailsFactory"]) : <any>undefined;
            this.user = _data["User"] ? ClaimsPrincipal.fromJS(_data["User"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ControllerBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ControllerBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HttpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        data["Request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["Response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["RouteData"] = this.routeData ? this.routeData.toJSON() : <any>undefined;
        data["ModelState"] = this.modelState ? this.modelState.toJSON() : <any>undefined;
        data["ControllerContext"] = this.controllerContext ? this.controllerContext.toJSON() : <any>undefined;
        data["MetadataProvider"] = this.metadataProvider ? this.metadataProvider.toJSON() : <any>undefined;
        data["ModelBinderFactory"] = this.modelBinderFactory ? this.modelBinderFactory.toJSON() : <any>undefined;
        data["Url"] = this.url ? this.url.toJSON() : <any>undefined;
        data["ObjectValidator"] = this.objectValidator ? this.objectValidator.toJSON() : <any>undefined;
        data["ProblemDetailsFactory"] = this.problemDetailsFactory ? this.problemDetailsFactory.toJSON() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IControllerBase {
    httpContext?: HttpContext | undefined;
    request?: HttpRequest | undefined;
    response?: HttpResponse | undefined;
    routeData?: RouteData | undefined;
    modelState?: ModelStateDictionary | undefined;
    controllerContext?: ControllerContext | undefined;
    metadataProvider?: IModelMetadataProvider | undefined;
    modelBinderFactory?: IModelBinderFactory | undefined;
    url?: IUrlHelper | undefined;
    objectValidator?: IObjectModelValidator | undefined;
    problemDetailsFactory?: ProblemDetailsFactory | undefined;
    user?: ClaimsPrincipal | undefined;
}

export class TodoItemsController extends ControllerBase implements ITodoItemsController {

    constructor(data?: ITodoItemsController) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TodoItemsController {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemsController();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITodoItemsController extends IControllerBase {
}

export abstract class HttpContext implements IHttpContext {

    constructor(data?: IHttpContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): HttpContext {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'HttpContext' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IHttpContext {
}

export abstract class HttpRequest implements IHttpRequest {
    bodyReader?: PipeReader | undefined;
    routeValues?: RouteValueDictionary | undefined;

    constructor(data?: IHttpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bodyReader = _data["BodyReader"] ? PipeReader.fromJS(_data["BodyReader"]) : <any>undefined;
            this.routeValues = _data["RouteValues"] ? RouteValueDictionary.fromJS(_data["RouteValues"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HttpRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'HttpRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BodyReader"] = this.bodyReader ? this.bodyReader.toJSON() : <any>undefined;
        data["RouteValues"] = this.routeValues ? this.routeValues.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHttpRequest {
    bodyReader?: PipeReader | undefined;
    routeValues?: RouteValueDictionary | undefined;
}

export abstract class PipeReader implements IPipeReader {

    constructor(data?: IPipeReader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PipeReader {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PipeReader' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IPipeReader {
}

export class RouteValueDictionary implements IRouteValueDictionary {
    _arrayStorage?: KeyValuePairOfStringAndObject[] | undefined;
    _propertyStorage?: PropertyStorage | undefined;
    item?: any | undefined;
    comparer?: IEqualityComparerOfString | undefined;
    count!: number;
    keys?: string[] | undefined;
    values?: any[] | undefined;

    constructor(data?: IRouteValueDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["_arrayStorage"])) {
                this._arrayStorage = [] as any;
                for (let item of _data["_arrayStorage"])
                    this._arrayStorage!.push(KeyValuePairOfStringAndObject.fromJS(item));
            }
            this._propertyStorage = _data["_propertyStorage"] ? PropertyStorage.fromJS(_data["_propertyStorage"]) : <any>undefined;
            this.item = _data["Item"];
            this.comparer = _data["Comparer"] ? IEqualityComparerOfString.fromJS(_data["Comparer"]) : <any>undefined;
            this.count = _data["Count"];
            if (Array.isArray(_data["Keys"])) {
                this.keys = [] as any;
                for (let item of _data["Keys"])
                    this.keys!.push(item);
            }
            if (Array.isArray(_data["Values"])) {
                this.values = [] as any;
                for (let item of _data["Values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): RouteValueDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new RouteValueDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this._arrayStorage)) {
            data["_arrayStorage"] = [];
            for (let item of this._arrayStorage)
                data["_arrayStorage"].push(item.toJSON());
        }
        data["_propertyStorage"] = this._propertyStorage ? this._propertyStorage.toJSON() : <any>undefined;
        data["Item"] = this.item;
        data["Comparer"] = this.comparer ? this.comparer.toJSON() : <any>undefined;
        data["Count"] = this.count;
        if (Array.isArray(this.keys)) {
            data["Keys"] = [];
            for (let item of this.keys)
                data["Keys"].push(item);
        }
        if (Array.isArray(this.values)) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item);
        }
        return data; 
    }
}

export interface IRouteValueDictionary {
    _arrayStorage?: KeyValuePairOfStringAndObject[] | undefined;
    _propertyStorage?: PropertyStorage | undefined;
    item?: any | undefined;
    comparer?: IEqualityComparerOfString | undefined;
    count: number;
    keys?: string[] | undefined;
    values?: any[] | undefined;
}

export class KeyValuePairOfStringAndObject implements IKeyValuePairOfStringAndObject {
    key!: string;
    value!: any;

    constructor(data?: IKeyValuePairOfStringAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["Key"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data; 
    }
}

export interface IKeyValuePairOfStringAndObject {
    key: string;
    value: any;
}

export class PropertyStorage implements IPropertyStorage {
    value?: any | undefined;
    properties?: PropertyHelper[] | undefined;

    constructor(data?: IPropertyStorage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"];
            if (Array.isArray(_data["Properties"])) {
                this.properties = [] as any;
                for (let item of _data["Properties"])
                    this.properties!.push(PropertyHelper.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyStorage {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyStorage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        if (Array.isArray(this.properties)) {
            data["Properties"] = [];
            for (let item of this.properties)
                data["Properties"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPropertyStorage {
    value?: any | undefined;
    properties?: PropertyHelper[] | undefined;
}

export class PropertyHelper implements IPropertyHelper {
    property?: PropertyInfo | undefined;
    name?: string | undefined;
    valueGetter?: FuncOfObjectAndObject | undefined;
    valueSetter?: ActionOfObjectAndObject | undefined;

    constructor(data?: IPropertyHelper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.property = _data["Property"] ? PropertyInfo.fromJS(_data["Property"]) : <any>undefined;
            this.name = _data["Name"];
            this.valueGetter = _data["ValueGetter"] ? FuncOfObjectAndObject.fromJS(_data["ValueGetter"]) : <any>undefined;
            this.valueSetter = _data["ValueSetter"] ? ActionOfObjectAndObject.fromJS(_data["ValueSetter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyHelper {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyHelper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Property"] = this.property ? this.property.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ValueGetter"] = this.valueGetter ? this.valueGetter.toJSON() : <any>undefined;
        data["ValueSetter"] = this.valueSetter ? this.valueSetter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPropertyHelper {
    property?: PropertyInfo | undefined;
    name?: string | undefined;
    valueGetter?: FuncOfObjectAndObject | undefined;
    valueSetter?: ActionOfObjectAndObject | undefined;
}

export abstract class MemberInfo implements IMemberInfo {
    module!: Module;
    customAttributes!: CustomAttributeData[];
    isCollectible!: boolean;
    metadataToken!: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.customAttributes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                this.customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            this.isCollectible = _data["IsCollectible"];
            this.metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MemberInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IMemberInfo {
    module: Module;
    customAttributes: CustomAttributeData[];
    isCollectible: boolean;
    metadataToken: number;
}

export abstract class PropertyInfo extends MemberInfo implements IPropertyInfo {
    memberType!: MemberTypes;
    isSpecialName!: boolean;
    getMethod?: MethodInfo | undefined;
    setMethod?: MethodInfo | undefined;

    constructor(data?: IPropertyInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.memberType = _data["MemberType"];
            this.isSpecialName = _data["IsSpecialName"];
            this.getMethod = _data["GetMethod"] ? MethodInfo.fromJS(_data["GetMethod"]) : <any>undefined;
            this.setMethod = _data["SetMethod"] ? MethodInfo.fromJS(_data["SetMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PropertyInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        data["IsSpecialName"] = this.isSpecialName;
        data["GetMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["SetMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IPropertyInfo extends IMemberInfo {
    memberType: MemberTypes;
    isSpecialName: boolean;
    getMethod?: MethodInfo | undefined;
    setMethod?: MethodInfo | undefined;
}

export enum MemberTypes {
    Constructor = 1,
    Event = 2,
    Field = 4,
    Method = 8,
    Property = 16,
    TypeInfo = 32,
    Custom = 64,
    NestedType = 128,
    All = 191,
}

export abstract class MethodBase extends MemberInfo implements IMethodBase {
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    isAbstract!: boolean;
    isConstructor!: boolean;
    isFinal!: boolean;
    isHideBySig!: boolean;
    isSpecialName!: boolean;
    isStatic!: boolean;
    isVirtual!: boolean;
    isAssembly!: boolean;
    isFamily!: boolean;
    isFamilyAndAssembly!: boolean;
    isFamilyOrAssembly!: boolean;
    isPrivate!: boolean;
    isPublic!: boolean;
    isConstructedGenericMethod!: boolean;
    isGenericMethod!: boolean;
    isGenericMethodDefinition!: boolean;
    containsGenericParameters!: boolean;
    isSecurityCritical!: boolean;
    isSecuritySafeCritical!: boolean;
    isSecurityTransparent!: boolean;

    constructor(data?: IMethodBase) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.methodImplementationFlags = _data["MethodImplementationFlags"];
            this.callingConvention = _data["CallingConvention"];
            this.isAbstract = _data["IsAbstract"];
            this.isConstructor = _data["IsConstructor"];
            this.isFinal = _data["IsFinal"];
            this.isHideBySig = _data["IsHideBySig"];
            this.isSpecialName = _data["IsSpecialName"];
            this.isStatic = _data["IsStatic"];
            this.isVirtual = _data["IsVirtual"];
            this.isAssembly = _data["IsAssembly"];
            this.isFamily = _data["IsFamily"];
            this.isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            this.isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            this.isPrivate = _data["IsPrivate"];
            this.isPublic = _data["IsPublic"];
            this.isConstructedGenericMethod = _data["IsConstructedGenericMethod"];
            this.isGenericMethod = _data["IsGenericMethod"];
            this.isGenericMethodDefinition = _data["IsGenericMethodDefinition"];
            this.containsGenericParameters = _data["ContainsGenericParameters"];
            this.isSecurityCritical = _data["IsSecurityCritical"];
            this.isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            this.isSecurityTransparent = _data["IsSecurityTransparent"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MethodBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MethodImplementationFlags"] = this.methodImplementationFlags;
        data["CallingConvention"] = this.callingConvention;
        data["IsAbstract"] = this.isAbstract;
        data["IsConstructor"] = this.isConstructor;
        data["IsFinal"] = this.isFinal;
        data["IsHideBySig"] = this.isHideBySig;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsVirtual"] = this.isVirtual;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["IsGenericMethod"] = this.isGenericMethod;
        data["IsGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        super.toJSON(data);
        return data; 
    }
}

export interface IMethodBase extends IMemberInfo {
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
}

export abstract class MethodInfo extends MethodBase implements IMethodInfo {
    memberType!: MemberTypes;
    returnParameter!: ParameterInfo;
    returnType!: string;

    constructor(data?: IMethodInfo) {
        super(data);
        if (!data) {
            this.returnParameter = new ParameterInfo();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.memberType = _data["MemberType"];
            this.returnParameter = _data["ReturnParameter"] ? ParameterInfo.fromJS(_data["ReturnParameter"]) : new ParameterInfo();
            this.returnType = _data["ReturnType"];
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MethodInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        data["ReturnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["ReturnType"] = this.returnType;
        super.toJSON(data);
        return data; 
    }
}

export interface IMethodInfo extends IMethodBase {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: string;
}

export class ParameterInfo implements IParameterInfo {
    attributes!: ParameterAttributes;
    member!: MemberInfo;
    name?: string | undefined;
    parameterType!: string;
    position!: number;
    isIn!: boolean;
    isLcid!: boolean;
    isOptional!: boolean;
    isOut!: boolean;
    isRetval!: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue!: boolean;
    customAttributes!: CustomAttributeData[];
    metadataToken!: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.customAttributes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["Attributes"];
            this.member = _data["Member"] ? MemberInfo.fromJS(_data["Member"]) : <any>undefined;
            this.name = _data["Name"];
            this.parameterType = _data["ParameterType"];
            this.position = _data["Position"];
            this.isIn = _data["IsIn"];
            this.isLcid = _data["IsLcid"];
            this.isOptional = _data["IsOptional"];
            this.isOut = _data["IsOut"];
            this.isRetval = _data["IsRetval"];
            this.defaultValue = _data["DefaultValue"];
            this.rawDefaultValue = _data["RawDefaultValue"];
            this.hasDefaultValue = _data["HasDefaultValue"];
            if (Array.isArray(_data["CustomAttributes"])) {
                this.customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            this.metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Attributes"] = this.attributes;
        data["Member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ParameterType"] = this.parameterType;
        data["Position"] = this.position;
        data["IsIn"] = this.isIn;
        data["IsLcid"] = this.isLcid;
        data["IsOptional"] = this.isOptional;
        data["IsOut"] = this.isOut;
        data["IsRetval"] = this.isRetval;
        data["DefaultValue"] = this.defaultValue;
        data["RawDefaultValue"] = this.rawDefaultValue;
        data["HasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    name?: string | undefined;
    parameterType: string;
    position: number;
    isIn: boolean;
    isLcid: boolean;
    isOptional: boolean;
    isOut: boolean;
    isRetval: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue: boolean;
    customAttributes: CustomAttributeData[];
    metadataToken: number;
}

export enum ParameterAttributes {
    None = 0,
    In = 1,
    Out = 2,
    Lcid = 4,
    Retval = 8,
    Optional = 16,
    HasDefault = 4096,
    HasFieldMarshal = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 61440,
}

export abstract class Module implements IModule {
    assembly!: Assembly;
    fullyQualifiedName!: string;
    name!: string;
    mDStreamVersion!: number;
    moduleVersionId!: string;
    scopeName!: string;
    moduleHandle!: ModuleHandle;
    customAttributes!: CustomAttributeData[];
    metadataToken!: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.moduleHandle = new ModuleHandle();
            this.customAttributes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["Assembly"] ? Assembly.fromJS(_data["Assembly"]) : <any>undefined;
            this.fullyQualifiedName = _data["FullyQualifiedName"];
            this.name = _data["Name"];
            this.mDStreamVersion = _data["MDStreamVersion"];
            this.moduleVersionId = _data["ModuleVersionId"];
            this.scopeName = _data["ScopeName"];
            this.moduleHandle = _data["ModuleHandle"] ? ModuleHandle.fromJS(_data["ModuleHandle"]) : new ModuleHandle();
            if (Array.isArray(_data["CustomAttributes"])) {
                this.customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            this.metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Module' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["FullyQualifiedName"] = this.fullyQualifiedName;
        data["Name"] = this.name;
        data["MDStreamVersion"] = this.mDStreamVersion;
        data["ModuleVersionId"] = this.moduleVersionId;
        data["ScopeName"] = this.scopeName;
        data["ModuleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IModule {
    assembly: Assembly;
    fullyQualifiedName: string;
    name: string;
    mDStreamVersion: number;
    moduleVersionId: string;
    scopeName: string;
    moduleHandle: ModuleHandle;
    customAttributes: CustomAttributeData[];
    metadataToken: number;
}

export abstract class Assembly implements IAssembly {
    definedTypes!: string[];
    exportedTypes!: string[];
    codeBase?: string | undefined;
    entryPoint?: MethodInfo | undefined;
    fullName?: string | undefined;
    imageRuntimeVersion!: string;
    isDynamic!: boolean;
    location!: string;
    reflectionOnly!: boolean;
    isCollectible!: boolean;
    isFullyTrusted!: boolean;
    customAttributes!: CustomAttributeData[];
    escapedCodeBase!: string;
    manifestModule!: Module;
    modules!: Module[];
    globalAssemblyCache!: boolean;
    hostContext!: number;
    securityRuleSet!: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.definedTypes = [];
            this.exportedTypes = [];
            this.customAttributes = [];
            this.modules = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["DefinedTypes"])) {
                this.definedTypes = [] as any;
                for (let item of _data["DefinedTypes"])
                    this.definedTypes!.push(item);
            }
            if (Array.isArray(_data["ExportedTypes"])) {
                this.exportedTypes = [] as any;
                for (let item of _data["ExportedTypes"])
                    this.exportedTypes!.push(item);
            }
            this.codeBase = _data["CodeBase"];
            this.entryPoint = _data["EntryPoint"] ? MethodInfo.fromJS(_data["EntryPoint"]) : <any>undefined;
            this.fullName = _data["FullName"];
            this.imageRuntimeVersion = _data["ImageRuntimeVersion"];
            this.isDynamic = _data["IsDynamic"];
            this.location = _data["Location"];
            this.reflectionOnly = _data["ReflectionOnly"];
            this.isCollectible = _data["IsCollectible"];
            this.isFullyTrusted = _data["IsFullyTrusted"];
            if (Array.isArray(_data["CustomAttributes"])) {
                this.customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            this.escapedCodeBase = _data["EscapedCodeBase"];
            this.manifestModule = _data["ManifestModule"] ? Module.fromJS(_data["ManifestModule"]) : <any>undefined;
            if (Array.isArray(_data["Modules"])) {
                this.modules = [] as any;
                for (let item of _data["Modules"])
                    this.modules!.push(Module.fromJS(item));
            }
            this.globalAssemblyCache = _data["GlobalAssemblyCache"];
            this.hostContext = _data["HostContext"];
            this.securityRuleSet = _data["SecurityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Assembly' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["DefinedTypes"] = [];
            for (let item of this.definedTypes)
                data["DefinedTypes"].push(item);
        }
        if (Array.isArray(this.exportedTypes)) {
            data["ExportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["ExportedTypes"].push(item);
        }
        data["CodeBase"] = this.codeBase;
        data["EntryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["FullName"] = this.fullName;
        data["ImageRuntimeVersion"] = this.imageRuntimeVersion;
        data["IsDynamic"] = this.isDynamic;
        data["Location"] = this.location;
        data["ReflectionOnly"] = this.reflectionOnly;
        data["IsCollectible"] = this.isCollectible;
        data["IsFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["EscapedCodeBase"] = this.escapedCodeBase;
        data["ManifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["Modules"] = [];
            for (let item of this.modules)
                data["Modules"].push(item.toJSON());
        }
        data["GlobalAssemblyCache"] = this.globalAssemblyCache;
        data["HostContext"] = this.hostContext;
        data["SecurityRuleSet"] = this.securityRuleSet;
        return data; 
    }
}

export interface IAssembly {
    definedTypes: string[];
    exportedTypes: string[];
    codeBase?: string | undefined;
    entryPoint?: MethodInfo | undefined;
    fullName?: string | undefined;
    imageRuntimeVersion: string;
    isDynamic: boolean;
    location: string;
    reflectionOnly: boolean;
    isCollectible: boolean;
    isFullyTrusted: boolean;
    customAttributes: CustomAttributeData[];
    escapedCodeBase: string;
    manifestModule: Module;
    modules: Module[];
    globalAssemblyCache: boolean;
    hostContext: number;
    securityRuleSet: SecurityRuleSet;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType!: string;
    constructor_!: ConstructorInfo;
    constructorArguments!: CustomAttributeTypedArgument[];
    namedArguments!: CustomAttributeNamedArgument[];

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.constructorArguments = [];
            this.namedArguments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["AttributeType"];
            this.constructor_ = _data["Constructor"] ? ConstructorInfo.fromJS(_data["Constructor"]) : <any>undefined;
            if (Array.isArray(_data["ConstructorArguments"])) {
                this.constructorArguments = [] as any;
                for (let item of _data["ConstructorArguments"])
                    this.constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["NamedArguments"])) {
                this.namedArguments = [] as any;
                for (let item of _data["NamedArguments"])
                    this.namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AttributeType"] = this.attributeType;
        data["Constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["ConstructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["ConstructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["NamedArguments"] = [];
            for (let item of this.namedArguments)
                data["NamedArguments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomAttributeData {
    attributeType: string;
    constructor_: ConstructorInfo;
    constructorArguments: CustomAttributeTypedArgument[];
    namedArguments: CustomAttributeNamedArgument[];
}

export abstract class ConstructorInfo extends MethodBase implements IConstructorInfo {
    memberType!: MemberTypes;

    constructor(data?: IConstructorInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.memberType = _data["MemberType"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ConstructorInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        super.toJSON(data);
        return data; 
    }
}

export interface IConstructorInfo extends IMethodBase {
    memberType: MemberTypes;
}

export enum MethodImplAttributes {
    IL = 0,
    Managed = 0,
    Native = 1,
    OPTIL = 2,
    Runtime = 3,
    CodeTypeMask = 3,
    Unmanaged = 4,
    ManagedMask = 4,
    NoInlining = 8,
    ForwardRef = 16,
    Synchronized = 32,
    NoOptimization = 64,
    PreserveSig = 128,
    AggressiveInlining = 256,
    AggressiveOptimization = 512,
    InternalCall = 4096,
    MaxMethodImplVal = 65535,
}

export enum CallingConventions {
    Standard = 1,
    VarArgs = 2,
    Any = 3,
    HasThis = 32,
    ExplicitThis = 64,
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType!: string;
    value?: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["ArgumentType"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ArgumentType"] = this.argumentType;
        data["Value"] = this.value;
        return data; 
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType: string;
    value?: any | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo!: MemberInfo;
    typedValue!: CustomAttributeTypedArgument;
    memberName!: string;
    isField!: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.typedValue = new CustomAttributeTypedArgument();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["MemberInfo"] ? MemberInfo.fromJS(_data["MemberInfo"]) : <any>undefined;
            this.typedValue = _data["TypedValue"] ? CustomAttributeTypedArgument.fromJS(_data["TypedValue"]) : new CustomAttributeTypedArgument();
            this.memberName = _data["MemberName"];
            this.isField = _data["IsField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["TypedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["MemberName"] = this.memberName;
        data["IsField"] = this.isField;
        return data; 
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    memberName: string;
    isField: boolean;
}

export enum SecurityRuleSet {
    None = 0,
    Level1 = 1,
    Level2 = 2,
}

export class ModuleHandle implements IModuleHandle {
    mDStreamVersion!: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mDStreamVersion = _data["MDStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MDStreamVersion"] = this.mDStreamVersion;
        return data; 
    }
}

export interface IModuleHandle {
    mDStreamVersion: number;
}

export abstract class Delegate implements IDelegate {
    target?: any | undefined;
    method!: MethodInfo;

    constructor(data?: IDelegate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Delegate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Delegate' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDelegate {
    target?: any | undefined;
    method: MethodInfo;
}

export abstract class MulticastDelegate extends Delegate implements IMulticastDelegate {

    constructor(data?: IMulticastDelegate) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): MulticastDelegate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MulticastDelegate' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IMulticastDelegate extends IDelegate {
}

export class FuncOfObjectAndObject extends MulticastDelegate implements IFuncOfObjectAndObject {

    constructor(data?: IFuncOfObjectAndObject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): FuncOfObjectAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new FuncOfObjectAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFuncOfObjectAndObject extends IMulticastDelegate {
}

export class ActionOfObjectAndObject extends MulticastDelegate implements IActionOfObjectAndObject {

    constructor(data?: IActionOfObjectAndObject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ActionOfObjectAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new ActionOfObjectAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IActionOfObjectAndObject extends IMulticastDelegate {
}

export abstract class IEqualityComparerOfString implements IIEqualityComparerOfString {

    constructor(data?: IIEqualityComparerOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IEqualityComparerOfString {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IEqualityComparerOfString' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIEqualityComparerOfString {
}

export abstract class HttpResponse implements IHttpResponse {
    bodyWriter?: PipeWriter | undefined;

    constructor(data?: IHttpResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bodyWriter = _data["BodyWriter"] ? PipeWriter.fromJS(_data["BodyWriter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HttpResponse {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'HttpResponse' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BodyWriter"] = this.bodyWriter ? this.bodyWriter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHttpResponse {
    bodyWriter?: PipeWriter | undefined;
}

export abstract class PipeWriter implements IPipeWriter {

    constructor(data?: IPipeWriter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PipeWriter {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PipeWriter' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IPipeWriter {
}

export class RouteData implements IRouteData {
    dataTokens?: RouteValueDictionary | undefined;
    routers?: IRouter[] | undefined;
    values?: RouteValueDictionary | undefined;

    constructor(data?: IRouteData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataTokens = _data["DataTokens"] ? RouteValueDictionary.fromJS(_data["DataTokens"]) : <any>undefined;
            if (Array.isArray(_data["Routers"])) {
                this.routers = [] as any;
                for (let item of _data["Routers"])
                    this.routers!.push(IRouter.fromJS(item));
            }
            this.values = _data["Values"] ? RouteValueDictionary.fromJS(_data["Values"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RouteData {
        data = typeof data === 'object' ? data : {};
        let result = new RouteData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DataTokens"] = this.dataTokens ? this.dataTokens.toJSON() : <any>undefined;
        if (Array.isArray(this.routers)) {
            data["Routers"] = [];
            for (let item of this.routers)
                data["Routers"].push(item.toJSON());
        }
        data["Values"] = this.values ? this.values.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRouteData {
    dataTokens?: RouteValueDictionary | undefined;
    routers?: IRouter[] | undefined;
    values?: RouteValueDictionary | undefined;
}

export abstract class IRouter implements IIRouter {

    constructor(data?: IIRouter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IRouter {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IRouter' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIRouter {
}

export class ModelStateDictionary implements IModelStateDictionary {
    root?: ModelStateEntry | undefined;
    maxAllowedErrors!: number;
    hasReachedMaxErrors!: boolean;
    errorCount!: number;
    count!: number;
    keys!: string[];
    values!: ModelStateEntry[];
    isValid!: boolean;
    validationState!: ModelValidationState;
    item?: ModelStateEntry | undefined;

    constructor(data?: IModelStateDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.keys = [];
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.root = _data["Root"] ? ModelStateEntry.fromJS(_data["Root"]) : <any>undefined;
            this.maxAllowedErrors = _data["MaxAllowedErrors"];
            this.hasReachedMaxErrors = _data["HasReachedMaxErrors"];
            this.errorCount = _data["ErrorCount"];
            this.count = _data["Count"];
            if (Array.isArray(_data["Keys"])) {
                this.keys = [] as any;
                for (let item of _data["Keys"])
                    this.keys!.push(item);
            }
            if (Array.isArray(_data["Values"])) {
                this.values = [] as any;
                for (let item of _data["Values"])
                    this.values!.push(ModelStateEntry.fromJS(item));
            }
            this.isValid = _data["IsValid"];
            this.validationState = _data["ValidationState"];
            this.item = _data["Item"] ? ModelStateEntry.fromJS(_data["Item"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModelStateDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new ModelStateDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Root"] = this.root ? this.root.toJSON() : <any>undefined;
        data["MaxAllowedErrors"] = this.maxAllowedErrors;
        data["HasReachedMaxErrors"] = this.hasReachedMaxErrors;
        data["ErrorCount"] = this.errorCount;
        data["Count"] = this.count;
        if (Array.isArray(this.keys)) {
            data["Keys"] = [];
            for (let item of this.keys)
                data["Keys"].push(item);
        }
        if (Array.isArray(this.values)) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item.toJSON());
        }
        data["IsValid"] = this.isValid;
        data["ValidationState"] = this.validationState;
        data["Item"] = this.item ? this.item.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IModelStateDictionary {
    root?: ModelStateEntry | undefined;
    maxAllowedErrors: number;
    hasReachedMaxErrors: boolean;
    errorCount: number;
    count: number;
    keys: string[];
    values: ModelStateEntry[];
    isValid: boolean;
    validationState: ModelValidationState;
    item?: ModelStateEntry | undefined;
}

export abstract class ModelStateEntry implements IModelStateEntry {
    rawValue?: any | undefined;
    attemptedValue?: string | undefined;
    errors?: ModelError[] | undefined;
    validationState!: ModelValidationState;

    constructor(data?: IModelStateEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rawValue = _data["RawValue"];
            this.attemptedValue = _data["AttemptedValue"];
            if (Array.isArray(_data["Errors"])) {
                this.errors = [] as any;
                for (let item of _data["Errors"])
                    this.errors!.push(ModelError.fromJS(item));
            }
            this.validationState = _data["ValidationState"];
        }
    }

    static fromJS(data: any): ModelStateEntry {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ModelStateEntry' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RawValue"] = this.rawValue;
        data["AttemptedValue"] = this.attemptedValue;
        if (Array.isArray(this.errors)) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item.toJSON());
        }
        data["ValidationState"] = this.validationState;
        return data; 
    }
}

export interface IModelStateEntry {
    rawValue?: any | undefined;
    attemptedValue?: string | undefined;
    errors?: ModelError[] | undefined;
    validationState: ModelValidationState;
}

export class ModelError implements IModelError {
    exception?: Exception | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IModelError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exception = _data["Exception"] ? Exception.fromJS(_data["Exception"]) : <any>undefined;
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): ModelError {
        data = typeof data === 'object' ? data : {};
        let result = new ModelError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Exception"] = this.exception ? this.exception.toJSON() : <any>undefined;
        data["ErrorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface IModelError {
    exception?: Exception | undefined;
    errorMessage?: string | undefined;
}

export class Exception implements IException {
    stackTrace?: string | undefined;
    message!: string;
    innerException?: Exception | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stackTrace = _data["StackTrace"];
            this.message = _data["Message"];
            this.innerException = _data["InnerException"] ? Exception.fromJS(_data["InnerException"]) : <any>undefined;
            this.source = _data["Source"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StackTrace"] = this.stackTrace;
        data["Message"] = this.message;
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["Source"] = this.source;
        return data; 
    }
}

export interface IException {
    stackTrace?: string | undefined;
    message: string;
    innerException?: Exception | undefined;
    source?: string | undefined;
}

export enum ModelValidationState {
    Unvalidated = 0,
    Invalid = 1,
    Valid = 2,
    Skipped = 3,
}

export class ActionContext implements IActionContext {
    actionDescriptor?: ActionDescriptor | undefined;
    httpContext?: HttpContext | undefined;
    modelState?: ModelStateDictionary | undefined;
    routeData?: RouteData | undefined;

    constructor(data?: IActionContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionDescriptor = _data["ActionDescriptor"] ? ActionDescriptor.fromJS(_data["ActionDescriptor"]) : <any>undefined;
            this.httpContext = _data["HttpContext"] ? HttpContext.fromJS(_data["HttpContext"]) : <any>undefined;
            this.modelState = _data["ModelState"] ? ModelStateDictionary.fromJS(_data["ModelState"]) : <any>undefined;
            this.routeData = _data["RouteData"] ? RouteData.fromJS(_data["RouteData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionContext {
        data = typeof data === 'object' ? data : {};
        let result = new ActionContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ActionDescriptor"] = this.actionDescriptor ? this.actionDescriptor.toJSON() : <any>undefined;
        data["HttpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        data["ModelState"] = this.modelState ? this.modelState.toJSON() : <any>undefined;
        data["RouteData"] = this.routeData ? this.routeData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActionContext {
    actionDescriptor?: ActionDescriptor | undefined;
    httpContext?: HttpContext | undefined;
    modelState?: ModelStateDictionary | undefined;
    routeData?: RouteData | undefined;
}

export class ControllerContext extends ActionContext implements IControllerContext {
    actionDescriptor?: ControllerActionDescriptor | undefined;
    valueProviderFactories?: IValueProviderFactory[] | undefined;

    constructor(data?: IControllerContext) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.actionDescriptor = _data["ActionDescriptor"] ? ControllerActionDescriptor.fromJS(_data["ActionDescriptor"]) : <any>undefined;
            if (Array.isArray(_data["ValueProviderFactories"])) {
                this.valueProviderFactories = [] as any;
                for (let item of _data["ValueProviderFactories"])
                    this.valueProviderFactories!.push(IValueProviderFactory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ControllerContext {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ActionDescriptor"] = this.actionDescriptor ? this.actionDescriptor.toJSON() : <any>undefined;
        if (Array.isArray(this.valueProviderFactories)) {
            data["ValueProviderFactories"] = [];
            for (let item of this.valueProviderFactories)
                data["ValueProviderFactories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IControllerContext extends IActionContext {
    actionDescriptor?: ControllerActionDescriptor | undefined;
    valueProviderFactories?: IValueProviderFactory[] | undefined;
}

export class ActionDescriptor implements IActionDescriptor {
    id?: string | undefined;
    routeValues?: { [key: string]: string; } | undefined;
    attributeRouteInfo?: AttributeRouteInfo | undefined;
    actionConstraints?: IActionConstraintMetadata[] | undefined;
    endpointMetadata?: any[] | undefined;
    parameters?: ParameterDescriptor[] | undefined;
    boundProperties?: ParameterDescriptor[] | undefined;
    filterDescriptors?: FilterDescriptor[] | undefined;
    displayName?: string | undefined;
    properties?: { [key: string]: any; } | undefined;

    constructor(data?: IActionDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            if (_data["RouteValues"]) {
                this.routeValues = {} as any;
                for (let key in _data["RouteValues"]) {
                    if (_data["RouteValues"].hasOwnProperty(key))
                        this.routeValues![key] = _data["RouteValues"][key];
                }
            }
            this.attributeRouteInfo = _data["AttributeRouteInfo"] ? AttributeRouteInfo.fromJS(_data["AttributeRouteInfo"]) : <any>undefined;
            if (Array.isArray(_data["ActionConstraints"])) {
                this.actionConstraints = [] as any;
                for (let item of _data["ActionConstraints"])
                    this.actionConstraints!.push(IActionConstraintMetadata.fromJS(item));
            }
            if (Array.isArray(_data["EndpointMetadata"])) {
                this.endpointMetadata = [] as any;
                for (let item of _data["EndpointMetadata"])
                    this.endpointMetadata!.push(item);
            }
            if (Array.isArray(_data["Parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["Parameters"])
                    this.parameters!.push(ParameterDescriptor.fromJS(item));
            }
            if (Array.isArray(_data["BoundProperties"])) {
                this.boundProperties = [] as any;
                for (let item of _data["BoundProperties"])
                    this.boundProperties!.push(ParameterDescriptor.fromJS(item));
            }
            if (Array.isArray(_data["FilterDescriptors"])) {
                this.filterDescriptors = [] as any;
                for (let item of _data["FilterDescriptors"])
                    this.filterDescriptors!.push(FilterDescriptor.fromJS(item));
            }
            this.displayName = _data["DisplayName"];
            if (_data["Properties"]) {
                this.properties = {} as any;
                for (let key in _data["Properties"]) {
                    if (_data["Properties"].hasOwnProperty(key))
                        this.properties![key] = _data["Properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ActionDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        if (this.routeValues) {
            data["RouteValues"] = {};
            for (let key in this.routeValues) {
                if (this.routeValues.hasOwnProperty(key))
                    data["RouteValues"][key] = this.routeValues[key];
            }
        }
        data["AttributeRouteInfo"] = this.attributeRouteInfo ? this.attributeRouteInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.actionConstraints)) {
            data["ActionConstraints"] = [];
            for (let item of this.actionConstraints)
                data["ActionConstraints"].push(item.toJSON());
        }
        if (Array.isArray(this.endpointMetadata)) {
            data["EndpointMetadata"] = [];
            for (let item of this.endpointMetadata)
                data["EndpointMetadata"].push(item);
        }
        if (Array.isArray(this.parameters)) {
            data["Parameters"] = [];
            for (let item of this.parameters)
                data["Parameters"].push(item.toJSON());
        }
        if (Array.isArray(this.boundProperties)) {
            data["BoundProperties"] = [];
            for (let item of this.boundProperties)
                data["BoundProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.filterDescriptors)) {
            data["FilterDescriptors"] = [];
            for (let item of this.filterDescriptors)
                data["FilterDescriptors"].push(item.toJSON());
        }
        data["DisplayName"] = this.displayName;
        if (this.properties) {
            data["Properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["Properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface IActionDescriptor {
    id?: string | undefined;
    routeValues?: { [key: string]: string; } | undefined;
    attributeRouteInfo?: AttributeRouteInfo | undefined;
    actionConstraints?: IActionConstraintMetadata[] | undefined;
    endpointMetadata?: any[] | undefined;
    parameters?: ParameterDescriptor[] | undefined;
    boundProperties?: ParameterDescriptor[] | undefined;
    filterDescriptors?: FilterDescriptor[] | undefined;
    displayName?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
}

export class ControllerActionDescriptor extends ActionDescriptor implements IControllerActionDescriptor {
    controllerName?: string | undefined;
    actionName?: string | undefined;
    methodInfo?: MethodInfo | undefined;
    controllerTypeInfo?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IControllerActionDescriptor) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.controllerName = _data["ControllerName"];
            this.actionName = _data["ActionName"];
            this.methodInfo = _data["MethodInfo"] ? MethodInfo.fromJS(_data["MethodInfo"]) : <any>undefined;
            this.controllerTypeInfo = _data["ControllerTypeInfo"];
            this.displayName = _data["DisplayName"];
        }
    }

    static fromJS(data: any): ControllerActionDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerActionDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ControllerName"] = this.controllerName;
        data["ActionName"] = this.actionName;
        data["MethodInfo"] = this.methodInfo ? this.methodInfo.toJSON() : <any>undefined;
        data["ControllerTypeInfo"] = this.controllerTypeInfo;
        data["DisplayName"] = this.displayName;
        super.toJSON(data);
        return data; 
    }
}

export interface IControllerActionDescriptor extends IActionDescriptor {
    controllerName?: string | undefined;
    actionName?: string | undefined;
    methodInfo?: MethodInfo | undefined;
    controllerTypeInfo?: string | undefined;
    displayName?: string | undefined;
}

export class AttributeRouteInfo implements IAttributeRouteInfo {
    template?: string | undefined;
    order!: number;
    name?: string | undefined;
    suppressLinkGeneration!: boolean;
    suppressPathMatching!: boolean;

    constructor(data?: IAttributeRouteInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["Template"];
            this.order = _data["Order"];
            this.name = _data["Name"];
            this.suppressLinkGeneration = _data["SuppressLinkGeneration"];
            this.suppressPathMatching = _data["SuppressPathMatching"];
        }
    }

    static fromJS(data: any): AttributeRouteInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeRouteInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Template"] = this.template;
        data["Order"] = this.order;
        data["Name"] = this.name;
        data["SuppressLinkGeneration"] = this.suppressLinkGeneration;
        data["SuppressPathMatching"] = this.suppressPathMatching;
        return data; 
    }
}

export interface IAttributeRouteInfo {
    template?: string | undefined;
    order: number;
    name?: string | undefined;
    suppressLinkGeneration: boolean;
    suppressPathMatching: boolean;
}

export abstract class IActionConstraintMetadata implements IIActionConstraintMetadata {

    constructor(data?: IIActionConstraintMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IActionConstraintMetadata {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IActionConstraintMetadata' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIActionConstraintMetadata {
}

export class ParameterDescriptor implements IParameterDescriptor {
    name?: string | undefined;
    parameterType?: string | undefined;
    bindingInfo?: BindingInfo | undefined;

    constructor(data?: IParameterDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.parameterType = _data["ParameterType"];
            this.bindingInfo = _data["BindingInfo"] ? BindingInfo.fromJS(_data["BindingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParameterDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["ParameterType"] = this.parameterType;
        data["BindingInfo"] = this.bindingInfo ? this.bindingInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IParameterDescriptor {
    name?: string | undefined;
    parameterType?: string | undefined;
    bindingInfo?: BindingInfo | undefined;
}

export class BindingInfo implements IBindingInfo {
    bindingSource?: BindingSource | undefined;
    binderModelName?: string | undefined;
    binderType?: string | undefined;
    propertyFilterProvider?: IPropertyFilterProvider | undefined;
    requestPredicate?: FuncOfActionContextAndBoolean | undefined;

    constructor(data?: IBindingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bindingSource = _data["BindingSource"] ? BindingSource.fromJS(_data["BindingSource"]) : <any>undefined;
            this.binderModelName = _data["BinderModelName"];
            this.binderType = _data["BinderType"];
            this.propertyFilterProvider = _data["PropertyFilterProvider"] ? IPropertyFilterProvider.fromJS(_data["PropertyFilterProvider"]) : <any>undefined;
            this.requestPredicate = _data["RequestPredicate"] ? FuncOfActionContextAndBoolean.fromJS(_data["RequestPredicate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BindingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BindingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BindingSource"] = this.bindingSource ? this.bindingSource.toJSON() : <any>undefined;
        data["BinderModelName"] = this.binderModelName;
        data["BinderType"] = this.binderType;
        data["PropertyFilterProvider"] = this.propertyFilterProvider ? this.propertyFilterProvider.toJSON() : <any>undefined;
        data["RequestPredicate"] = this.requestPredicate ? this.requestPredicate.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBindingInfo {
    bindingSource?: BindingSource | undefined;
    binderModelName?: string | undefined;
    binderType?: string | undefined;
    propertyFilterProvider?: IPropertyFilterProvider | undefined;
    requestPredicate?: FuncOfActionContextAndBoolean | undefined;
}

export class BindingSource implements IBindingSource {
    displayName?: string | undefined;
    id?: string | undefined;
    isGreedy!: boolean;
    isFromRequest!: boolean;

    constructor(data?: IBindingSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["DisplayName"];
            this.id = _data["Id"];
            this.isGreedy = _data["IsGreedy"];
            this.isFromRequest = _data["IsFromRequest"];
        }
    }

    static fromJS(data: any): BindingSource {
        data = typeof data === 'object' ? data : {};
        let result = new BindingSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DisplayName"] = this.displayName;
        data["Id"] = this.id;
        data["IsGreedy"] = this.isGreedy;
        data["IsFromRequest"] = this.isFromRequest;
        return data; 
    }
}

export interface IBindingSource {
    displayName?: string | undefined;
    id?: string | undefined;
    isGreedy: boolean;
    isFromRequest: boolean;
}

export abstract class IPropertyFilterProvider implements IIPropertyFilterProvider {
    propertyFilter?: FuncOfModelMetadataAndBoolean | undefined;

    constructor(data?: IIPropertyFilterProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyFilter = _data["PropertyFilter"] ? FuncOfModelMetadataAndBoolean.fromJS(_data["PropertyFilter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IPropertyFilterProvider {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IPropertyFilterProvider' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PropertyFilter"] = this.propertyFilter ? this.propertyFilter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIPropertyFilterProvider {
    propertyFilter?: FuncOfModelMetadataAndBoolean | undefined;
}

export class FuncOfModelMetadataAndBoolean extends MulticastDelegate implements IFuncOfModelMetadataAndBoolean {

    constructor(data?: IFuncOfModelMetadataAndBoolean) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): FuncOfModelMetadataAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new FuncOfModelMetadataAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFuncOfModelMetadataAndBoolean extends IMulticastDelegate {
}

export class FuncOfActionContextAndBoolean extends MulticastDelegate implements IFuncOfActionContextAndBoolean {

    constructor(data?: IFuncOfActionContextAndBoolean) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): FuncOfActionContextAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new FuncOfActionContextAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFuncOfActionContextAndBoolean extends IMulticastDelegate {
}

export class FilterDescriptor implements IFilterDescriptor {
    filter?: IFilterMetadata | undefined;
    order!: number;
    scope!: number;

    constructor(data?: IFilterDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["Filter"] ? IFilterMetadata.fromJS(_data["Filter"]) : <any>undefined;
            this.order = _data["Order"];
            this.scope = _data["Scope"];
        }
    }

    static fromJS(data: any): FilterDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new FilterDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["Order"] = this.order;
        data["Scope"] = this.scope;
        return data; 
    }
}

export interface IFilterDescriptor {
    filter?: IFilterMetadata | undefined;
    order: number;
    scope: number;
}

export abstract class IFilterMetadata implements IIFilterMetadata {

    constructor(data?: IIFilterMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IFilterMetadata {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IFilterMetadata' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIFilterMetadata {
}

export abstract class IValueProviderFactory implements IIValueProviderFactory {

    constructor(data?: IIValueProviderFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IValueProviderFactory {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IValueProviderFactory' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIValueProviderFactory {
}

export abstract class IModelMetadataProvider implements IIModelMetadataProvider {

    constructor(data?: IIModelMetadataProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IModelMetadataProvider {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IModelMetadataProvider' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIModelMetadataProvider {
}

export abstract class IModelBinderFactory implements IIModelBinderFactory {

    constructor(data?: IIModelBinderFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IModelBinderFactory {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IModelBinderFactory' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIModelBinderFactory {
}

export abstract class IUrlHelper implements IIUrlHelper {
    actionContext?: ActionContext | undefined;

    constructor(data?: IIUrlHelper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionContext = _data["ActionContext"] ? ActionContext.fromJS(_data["ActionContext"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IUrlHelper {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IUrlHelper' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ActionContext"] = this.actionContext ? this.actionContext.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIUrlHelper {
    actionContext?: ActionContext | undefined;
}

export abstract class IObjectModelValidator implements IIObjectModelValidator {

    constructor(data?: IIObjectModelValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IObjectModelValidator {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IObjectModelValidator' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIObjectModelValidator {
}

export abstract class ProblemDetailsFactory implements IProblemDetailsFactory {

    constructor(data?: IProblemDetailsFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ProblemDetailsFactory {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ProblemDetailsFactory' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IProblemDetailsFactory {
}

export class ClaimsPrincipal implements IClaimsPrincipal {
    claims?: Claim[] | undefined;
    identities?: ClaimsIdentity[] | undefined;
    identity?: IIdentity | undefined;

    constructor(data?: IClaimsPrincipal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Claims"])) {
                this.claims = [] as any;
                for (let item of _data["Claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            if (Array.isArray(_data["Identities"])) {
                this.identities = [] as any;
                for (let item of _data["Identities"])
                    this.identities!.push(ClaimsIdentity.fromJS(item));
            }
            this.identity = _data["Identity"] ? IIdentity.fromJS(_data["Identity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClaimsPrincipal {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsPrincipal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["Claims"] = [];
            for (let item of this.claims)
                data["Claims"].push(item.toJSON());
        }
        if (Array.isArray(this.identities)) {
            data["Identities"] = [];
            for (let item of this.identities)
                data["Identities"].push(item.toJSON());
        }
        data["Identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IClaimsPrincipal {
    claims?: Claim[] | undefined;
    identities?: ClaimsIdentity[] | undefined;
    identity?: IIdentity | undefined;
}

export class Claim implements IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    properties?: { [key: string]: string; } | undefined;
    subject?: ClaimsIdentity | undefined;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issuer = _data["Issuer"];
            this.originalIssuer = _data["OriginalIssuer"];
            if (_data["Properties"]) {
                this.properties = {} as any;
                for (let key in _data["Properties"]) {
                    if (_data["Properties"].hasOwnProperty(key))
                        this.properties![key] = _data["Properties"][key];
                }
            }
            this.subject = _data["Subject"] ? ClaimsIdentity.fromJS(_data["Subject"]) : <any>undefined;
            this.type = _data["Type"];
            this.value = _data["Value"];
            this.valueType = _data["ValueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Issuer"] = this.issuer;
        data["OriginalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["Properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["Properties"][key] = this.properties[key];
            }
        }
        data["Subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["Type"] = this.type;
        data["Value"] = this.value;
        data["ValueType"] = this.valueType;
        return data; 
    }
}

export interface IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    properties?: { [key: string]: string; } | undefined;
    subject?: ClaimsIdentity | undefined;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated!: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string | undefined;
    roleClaimType?: string | undefined;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["AuthenticationType"];
            this.isAuthenticated = _data["IsAuthenticated"];
            this.actor = _data["Actor"] ? ClaimsIdentity.fromJS(_data["Actor"]) : <any>undefined;
            this.bootstrapContext = _data["BootstrapContext"];
            if (Array.isArray(_data["Claims"])) {
                this.claims = [] as any;
                for (let item of _data["Claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.label = _data["Label"];
            this.name = _data["Name"];
            this.nameClaimType = _data["NameClaimType"];
            this.roleClaimType = _data["RoleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AuthenticationType"] = this.authenticationType;
        data["IsAuthenticated"] = this.isAuthenticated;
        data["Actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["BootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["Claims"] = [];
            for (let item of this.claims)
                data["Claims"].push(item.toJSON());
        }
        data["Label"] = this.label;
        data["Name"] = this.name;
        data["NameClaimType"] = this.nameClaimType;
        data["RoleClaimType"] = this.roleClaimType;
        return data; 
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string | undefined;
    roleClaimType?: string | undefined;
}

export abstract class IIdentity implements IIIdentity {
    authenticationType?: string | undefined;
    isAuthenticated!: boolean;
    name?: string | undefined;

    constructor(data?: IIIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["AuthenticationType"];
            this.isAuthenticated = _data["IsAuthenticated"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): IIdentity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IIdentity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AuthenticationType"] = this.authenticationType;
        data["IsAuthenticated"] = this.isAuthenticated;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IIIdentity {
    authenticationType?: string | undefined;
    isAuthenticated: boolean;
    name?: string | undefined;
}

export class DbContext implements IDbContext {
    database?: DatabaseFacade | undefined;
    changeTracker?: ChangeTracker | undefined;
    model?: IModel | undefined;
    contextId!: DbContextId;

    constructor(data?: IDbContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contextId = new DbContextId();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.database = _data["Database"] ? DatabaseFacade.fromJS(_data["Database"]) : <any>undefined;
            this.changeTracker = _data["ChangeTracker"] ? ChangeTracker.fromJS(_data["ChangeTracker"]) : <any>undefined;
            this.model = _data["Model"] ? IModel.fromJS(_data["Model"]) : <any>undefined;
            this.contextId = _data["ContextId"] ? DbContextId.fromJS(_data["ContextId"]) : new DbContextId();
        }
    }

    static fromJS(data: any): DbContext {
        data = typeof data === 'object' ? data : {};
        let result = new DbContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Database"] = this.database ? this.database.toJSON() : <any>undefined;
        data["ChangeTracker"] = this.changeTracker ? this.changeTracker.toJSON() : <any>undefined;
        data["Model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["ContextId"] = this.contextId ? this.contextId.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDbContext {
    database?: DatabaseFacade | undefined;
    changeTracker?: ChangeTracker | undefined;
    model?: IModel | undefined;
    contextId: DbContextId;
}

export class TodoContext extends DbContext implements ITodoContext {
    todoItems?: TodoItem[] | undefined;

    constructor(data?: ITodoContext) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["TodoItems"])) {
                this.todoItems = [] as any;
                for (let item of _data["TodoItems"])
                    this.todoItems!.push(TodoItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoContext {
        data = typeof data === 'object' ? data : {};
        let result = new TodoContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.todoItems)) {
            data["TodoItems"] = [];
            for (let item of this.todoItems)
                data["TodoItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITodoContext extends IDbContext {
    todoItems?: TodoItem[] | undefined;
}

export class TodoItem implements ITodoItem {
    id!: number;
    name?: string | undefined;
    isComplete!: boolean;

    constructor(data?: ITodoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.isComplete = _data["IsComplete"];
        }
    }

    static fromJS(data: any): TodoItem {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["IsComplete"] = this.isComplete;
        return data; 
    }
}

export interface ITodoItem {
    id: number;
    name?: string | undefined;
    isComplete: boolean;
}

export class DatabaseFacade implements IDatabaseFacade {
    currentTransaction?: IDbContextTransaction | undefined;
    autoTransactionsEnabled!: boolean;
    providerName?: string | undefined;

    constructor(data?: IDatabaseFacade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentTransaction = _data["CurrentTransaction"] ? IDbContextTransaction.fromJS(_data["CurrentTransaction"]) : <any>undefined;
            this.autoTransactionsEnabled = _data["AutoTransactionsEnabled"];
            this.providerName = _data["ProviderName"];
        }
    }

    static fromJS(data: any): DatabaseFacade {
        data = typeof data === 'object' ? data : {};
        let result = new DatabaseFacade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CurrentTransaction"] = this.currentTransaction ? this.currentTransaction.toJSON() : <any>undefined;
        data["AutoTransactionsEnabled"] = this.autoTransactionsEnabled;
        data["ProviderName"] = this.providerName;
        return data; 
    }
}

export interface IDatabaseFacade {
    currentTransaction?: IDbContextTransaction | undefined;
    autoTransactionsEnabled: boolean;
    providerName?: string | undefined;
}

export abstract class IDbContextTransaction implements IIDbContextTransaction {
    transactionId!: string;

    constructor(data?: IIDbContextTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["TransactionId"];
        }
    }

    static fromJS(data: any): IDbContextTransaction {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IDbContextTransaction' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TransactionId"] = this.transactionId;
        return data; 
    }
}

export interface IIDbContextTransaction {
    transactionId: string;
}

export class ChangeTracker implements IChangeTracker {
    autoDetectChangesEnabled!: boolean;
    lazyLoadingEnabled!: boolean;
    queryTrackingBehavior!: QueryTrackingBehavior;
    deleteOrphansTiming!: CascadeTiming;
    cascadeDeleteTiming!: CascadeTiming;
    context?: DbContext | undefined;

    constructor(data?: IChangeTracker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoDetectChangesEnabled = _data["AutoDetectChangesEnabled"];
            this.lazyLoadingEnabled = _data["LazyLoadingEnabled"];
            this.queryTrackingBehavior = _data["QueryTrackingBehavior"];
            this.deleteOrphansTiming = _data["DeleteOrphansTiming"];
            this.cascadeDeleteTiming = _data["CascadeDeleteTiming"];
            this.context = _data["Context"] ? DbContext.fromJS(_data["Context"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChangeTracker {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeTracker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AutoDetectChangesEnabled"] = this.autoDetectChangesEnabled;
        data["LazyLoadingEnabled"] = this.lazyLoadingEnabled;
        data["QueryTrackingBehavior"] = this.queryTrackingBehavior;
        data["DeleteOrphansTiming"] = this.deleteOrphansTiming;
        data["CascadeDeleteTiming"] = this.cascadeDeleteTiming;
        data["Context"] = this.context ? this.context.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IChangeTracker {
    autoDetectChangesEnabled: boolean;
    lazyLoadingEnabled: boolean;
    queryTrackingBehavior: QueryTrackingBehavior;
    deleteOrphansTiming: CascadeTiming;
    cascadeDeleteTiming: CascadeTiming;
    context?: DbContext | undefined;
}

export enum QueryTrackingBehavior {
    TrackAll = 0,
    NoTracking = 1,
}

export enum CascadeTiming {
    Immediate = 0,
    OnSaveChanges = 1,
    Never = 2,
}

export abstract class IModel implements IIModel {

    constructor(data?: IIModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IModel {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IModel' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIModel {
}

export class DbContextId implements IDbContextId {
    instanceId!: string;
    lease!: number;

    constructor(data?: IDbContextId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.instanceId = _data["InstanceId"];
            this.lease = _data["Lease"];
        }
    }

    static fromJS(data: any): DbContextId {
        data = typeof data === 'object' ? data : {};
        let result = new DbContextId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["InstanceId"] = this.instanceId;
        data["Lease"] = this.lease;
        return data; 
    }
}

export interface IDbContextId {
    instanceId: string;
    lease: number;
}

export class Program implements IProgram {

    constructor(data?: IProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Program {
        data = typeof data === 'object' ? data : {};
        let result = new Program();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IProgram {
}

export class Startup implements IStartup {
    configuration?: IConfiguration | undefined;

    constructor(data?: IStartup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configuration = _data["Configuration"] ? IConfiguration.fromJS(_data["Configuration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Startup {
        data = typeof data === 'object' ? data : {};
        let result = new Startup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStartup {
    configuration?: IConfiguration | undefined;
}

export abstract class IConfiguration implements IIConfiguration {

    constructor(data?: IIConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IConfiguration {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IConfiguration' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIConfiguration {
}

}